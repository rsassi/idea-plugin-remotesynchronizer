package org.sylfra.idea.plugins.remotesynchronizer.listener;

import com.intellij.openapi.compiler.CompilationStatusListener;
import com.intellij.openapi.compiler.CompileContext;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.util.ui.UIUtil;
import org.sylfra.idea.plugins.remotesynchronizer.RemoteSynchronizerPlugin;
import org.sylfra.idea.plugins.remotesynchronizer.synchronizing.Synchronizer;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

/**
 * @author Thomas Demande
 */
public class CompilationListener implements CompilationStatusListener {
    private List<VirtualFile> compiledFiles = new ArrayList(new HashSet(2000));

    public void compilationFinished(boolean b, int i, int i2, final CompileContext compileContext) {
        // Getting the needed array of virtual files to be sync'ed then emptying the list for the next compilation
        final VirtualFile[] virtualFiles = compiledFiles.toArray((new VirtualFile[compiledFiles.size()]));
        compiledFiles.clear();

        // Sending synchronization order, in the UI thread. Compiler context might be null if no SDK has been defined in the project
        UIUtil.invokeAndWaitIfNeeded(new Runnable() {
            public void run() {
                if(compileContext != null){
                    Synchronizer.performSynchronization(RemoteSynchronizerPlugin.getInstance(compileContext.getProject()), virtualFiles);
                }
            }
        });
    }

    public void fileGenerated(final String s, final String s2) {
        //Adding files generated by the compilation work to a list that will be treated as a whole when compilation is totally finished
        compiledFiles.add(LocalFileSystem.getInstance().findFileByIoFile(new File(s, s2)));

    }
}
